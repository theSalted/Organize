<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>top-level-items</key>
	<array>
		<dict>
			<key>destination</key>
			<dict>
				<key>location-parameters</key>
				<dict>
					<key>EndingColumnNumber</key>
					<string>0</string>
					<key>EndingLineNumber</key>
					<string>49</string>
					<key>StartingColumnNumber</key>
					<string>0</string>
					<key>StartingLineNumber</key>
					<string>34</string>
					<key>Timestamp</key>
					<string>730319127.018515</string>
				</dict>
				<key>rebasable-url</key>
				<dict>
					<key>base</key>
					<string>workspace</string>
					<key>payload</key>
					<dict>
						<key>relative-path</key>
						<string>Organize/ContentView.swift</string>
					</dict>
				</dict>
			</dict>
			<key>text-context</key>
			<dict>
				<key>focused</key>
				<string>            ItemCaptureView()
                .overlay {
                    if storages.isEmpty {
                        ZStack {
                            RoundedRectangle(cornerRadius: 10)
                                .foregroundStyle(.regularMaterial)
                            ContentUnavailableView(
                                "Create a Storage First",
                                systemImage: "archivebox",
                                description: "Can't create item because there is no available storage for them".inText)
                        }
                        .frame(height: 500)
                        .padding()
                    }
                }
</string>
				<key>leading</key>
				<string>                .environment(captureViewModel)
            #if !targetEnvironment(simulator)
</string>
				<key>trailing</key>
				<string>                .disabled(storages.isEmpty)
                .tabItem {
                    Label("Capture", systemImage: "cube.fill")
</string>
			</dict>
			<key>title</key>
			<string>Todo: revisit needed on how to present create item form for capture view</string>
			<key>type</key>
			<string>bookmark</string>
		</dict>
		<dict>
			<key>destination</key>
			<dict>
				<key>location-parameters</key>
				<dict>
					<key>EndingColumnNumber</key>
					<string>0</string>
					<key>EndingLineNumber</key>
					<string>31</string>
					<key>StartingColumnNumber</key>
					<string>0</string>
					<key>StartingLineNumber</key>
					<string>30</string>
					<key>Timestamp</key>
					<string>729804853.105293</string>
				</dict>
				<key>rebasable-url</key>
				<dict>
					<key>base</key>
					<string>workspace</string>
					<key>payload</key>
					<dict>
						<key>relative-path</key>
						<string>Organize/Views/OrganizationTabViews/NavigationColumns/SideBarView.swift</string>
					</dict>
				</dict>
			</dict>
			<key>text-context</key>
			<dict>
				<key>focused</key>
				<string>            // TODO: Improve needed for the match algorithm in this computed property
</string>
				<key>leading</key>
				<string>            return spaces
        } else {
</string>
				<key>trailing</key>
				<string>            // -[ ] Better fuzzy match algorithm
            // -[ ] Implementation in generic of string extension
            return spaces.filter { space in
</string>
			</dict>
			<key>title</key>
			<string>Improve needed for the match algorithm in this computed property</string>
			<key>type</key>
			<string>bookmark</string>
		</dict>
		<dict>
			<key>destination</key>
			<dict>
				<key>location-parameters</key>
				<dict>
					<key>EndingColumnNumber</key>
					<string>0</string>
					<key>EndingLineNumber</key>
					<string>34</string>
					<key>StartingColumnNumber</key>
					<string>0</string>
					<key>StartingLineNumber</key>
					<string>33</string>
					<key>Timestamp</key>
					<string>729874150.833233</string>
				</dict>
				<key>rebasable-url</key>
				<dict>
					<key>base</key>
					<string>workspace</string>
					<key>payload</key>
					<dict>
						<key>relative-path</key>
						<string>Organize/Views/OrganizationTabViews/NavigationColumns/DetailsView.swift</string>
					</dict>
				</dict>
			</dict>
			<key>text-context</key>
			<dict>
				<key>focused</key>
				<string>        // TODO: SwiftUI bug Page Indicator TabView page style lightmode workaround
</string>
				<key>leading</key>
				<string>    
    init() {
</string>
				<key>trailing</key>
				<string>        // PageIndicator of TabViewStyle don't adopt to lightmode for some reason
        // manual implementation for lightmode
        // For currentPageIndicatorTintColor I choose .label, but .tint also works
</string>
			</dict>
			<key>type</key>
			<string>bookmark</string>
		</dict>
		<dict>
			<key>destination</key>
			<dict>
				<key>location-parameters</key>
				<dict>
					<key>EndingColumnNumber</key>
					<string>0</string>
					<key>EndingLineNumber</key>
					<string>28</string>
					<key>StartingColumnNumber</key>
					<string>0</string>
					<key>StartingLineNumber</key>
					<string>27</string>
					<key>Timestamp</key>
					<string>729884771.886156</string>
				</dict>
				<key>rebasable-url</key>
				<dict>
					<key>base</key>
					<string>workspace</string>
					<key>payload</key>
					<dict>
						<key>relative-path</key>
						<string>Organize/Views/OrganizationTabViews/NavigationColumns/ContentColumnView.swift</string>
					</dict>
				</dict>
			</dict>
			<key>text-context</key>
			<dict>
				<key>focused</key>
				<string>        // TODO: Improve needed for the match algorithm in this computed property
</string>
				<key>leading</key>
				<string>    }
    private var storagesList: [Storage] {
</string>
				<key>trailing</key>
				<string>        // -[ ] Better fuzzy match algorithm
        // -[ ] Implementation in generic of string extension
        return storages.filter { storage in
</string>
			</dict>
			<key>type</key>
			<string>bookmark</string>
		</dict>
		<dict>
			<key>destination</key>
			<dict>
				<key>location-parameters</key>
				<dict>
					<key>EndingColumnNumber</key>
					<string>0</string>
					<key>EndingLineNumber</key>
					<string>29</string>
					<key>StartingColumnNumber</key>
					<string>0</string>
					<key>StartingLineNumber</key>
					<string>28</string>
					<key>Timestamp</key>
					<string>729882206.10893</string>
				</dict>
				<key>rebasable-url</key>
				<dict>
					<key>base</key>
					<string>workspace</string>
					<key>payload</key>
					<dict>
						<key>relative-path</key>
						<string>Organize/Views/OrganizationTabViews/NavigationColumns/DetailViews/StorageViews/SingleStorageDetailView.swift</string>
					</dict>
				</dict>
			</dict>
			<key>text-context</key>
			<dict>
				<key>focused</key>
				<string>        // TODO: Improve needed for the match algorithm in this computed property
</string>
				<key>leading</key>
				<string>    }
    private var itemsList: [Item] {
</string>
				<key>trailing</key>
				<string>        // -[ ] Better fuzzy match algorithm
        // -[ ] Implementation in generic of string extension
        return items.filter { item in
</string>
			</dict>
			<key>type</key>
			<string>bookmark</string>
		</dict>
		<dict>
			<key>destination</key>
			<dict>
				<key>location-parameters</key>
				<dict>
					<key>EndingColumnNumber</key>
					<string>47</string>
					<key>EndingLineNumber</key>
					<string>11</string>
					<key>StartingColumnNumber</key>
					<string>47</string>
					<key>StartingLineNumber</key>
					<string>11</string>
					<key>Timestamp</key>
					<string>729975624.3859791</string>
				</dict>
				<key>rebasable-url</key>
				<dict>
					<key>base</key>
					<string>workspace</string>
					<key>payload</key>
					<dict>
						<key>relative-path</key>
						<string>Organize/ViewModels/SpaceScanViewModel.swift</string>
					</dict>
				</dict>
			</dict>
			<key>text-context</key>
			<dict>
				<key>focused</key>
				<string></string>
				<key>leading</key>
				<string>import RoomPlan

// TODO: Upgrade to using observation framework</string>
				<key>trailing</key>
				<string>
class SpaceScanViewModel: ObservableObject {
    enum Action {
</string>
			</dict>
			<key>type</key>
			<string>bookmark</string>
		</dict>
		<dict>
			<key>destination</key>
			<dict>
				<key>location-parameters</key>
				<dict>
					<key>EndingColumnNumber</key>
					<string>108</string>
					<key>EndingLineNumber</key>
					<string>19</string>
					<key>StartingColumnNumber</key>
					<string>108</string>
					<key>StartingLineNumber</key>
					<string>19</string>
					<key>Timestamp</key>
					<string>729975764.996453</string>
				</dict>
				<key>rebasable-url</key>
				<dict>
					<key>base</key>
					<string>workspace</string>
					<key>payload</key>
					<dict>
						<key>relative-path</key>
						<string>Organize/ViewModels/SpaceScanViewModel.swift</string>
					</dict>
				</dict>
			</dict>
			<key>text-context</key>
			<dict>
				<key>focused</key>
				<string></string>
				<key>leading</key>
				<string>        case export
    }
    </string>
				<key>trailing</key>
				<string>
    // TODO: Is Combine really necessary here? I dislike an observer pattern sticking inside of MVVM pattern
    // TODO: These are really data models, URLs should be using the same filemanager system CapturedObject is using
</string>
			</dict>
			<key>type</key>
			<string>bookmark</string>
		</dict>
		<dict>
			<key>destination</key>
			<dict>
				<key>location-parameters</key>
				<dict>
					<key>EndingColumnNumber</key>
					<string>108</string>
					<key>EndingLineNumber</key>
					<string>20</string>
					<key>StartingColumnNumber</key>
					<string>108</string>
					<key>StartingLineNumber</key>
					<string>20</string>
					<key>Timestamp</key>
					<string>729975769.0921</string>
				</dict>
				<key>rebasable-url</key>
				<dict>
					<key>base</key>
					<string>workspace</string>
					<key>payload</key>
					<dict>
						<key>relative-path</key>
						<string>Organize/ViewModels/SpaceScanViewModel.swift</string>
					</dict>
				</dict>
			</dict>
			<key>text-context</key>
			<dict>
				<key>focused</key>
				<string></string>
				<key>leading</key>
				<string>    }
    
    // TODO: Is Combine really necessary here? I dislike an observer pattern sticking inside of MVVM pattern</string>
				<key>trailing</key>
				<string>
    // TODO: These are really data models, URLs should be using the same filemanager system CapturedObject is using
    var actions = PassthroughSubject&lt;Action, Never&gt;();
</string>
			</dict>
			<key>type</key>
			<string>bookmark</string>
		</dict>
		<dict>
			<key>destination</key>
			<dict>
				<key>location-parameters</key>
				<dict>
					<key>EndingColumnNumber</key>
					<string>0</string>
					<key>EndingLineNumber</key>
					<string>12</string>
					<key>StartingColumnNumber</key>
					<string>0</string>
					<key>StartingLineNumber</key>
					<string>11</string>
					<key>Timestamp</key>
					<string>729977009.093461</string>
				</dict>
				<key>rebasable-url</key>
				<dict>
					<key>base</key>
					<string>workspace</string>
					<key>payload</key>
					<dict>
						<key>relative-path</key>
						<string>Organize/Extensions/CapturedRoom+Equatable.swift</string>
					</dict>
				</dict>
			</dict>
			<key>text-context</key>
			<dict>
				<key>focused</key>
				<string>// TODO: May need a better way, this is extremely sketchy way in so many ways. I implement equitable here to solve a very specific problem of matching two Rooms that have extremely similar coordinates. But extremely similar coordinator of all objects shouldn't mean the CapturedRooms are equal. And other properties is also not consider here.
</string>
				<key>leading</key>
				<string>import OSLog

</string>
				<key>trailing</key>
				<string>extension CapturedRoom: Equatable {
    public static func == (lhs: CapturedRoom, rhs: CapturedRoom) -&gt; Bool {
        logger.warning("Equatable implementation for CaptureRoom is very flawed at this moment because it only compare objects of two CapturedRooms without taking account of other properties. And Object's implementation is also flawed")
</string>
			</dict>
			<key>type</key>
			<string>bookmark</string>
		</dict>
		<dict>
			<key>destination</key>
			<dict>
				<key>location-parameters</key>
				<dict>
					<key>EndingColumnNumber</key>
					<string>0</string>
					<key>EndingLineNumber</key>
					<string>12</string>
					<key>StartingColumnNumber</key>
					<string>0</string>
					<key>StartingLineNumber</key>
					<string>11</string>
					<key>Timestamp</key>
					<string>729976769.160261</string>
				</dict>
				<key>rebasable-url</key>
				<dict>
					<key>base</key>
					<string>workspace</string>
					<key>payload</key>
					<dict>
						<key>relative-path</key>
						<string>Organize/Extensions/CapturedRoom.Object+Equatable.swift</string>
					</dict>
				</dict>
			</dict>
			<key>text-context</key>
			<dict>
				<key>focused</key>
				<string>// TODO: May need a better way, this is extremely sketchy way in so many ways. I implement equitable here to solve a very specific problem of matching two Rooms that have extremely similar coordinates. But extremely similar coordinator of all objects shouldn't mean the CapturedRooms are equal. And other properties is also not consider here.
</string>
				<key>leading</key>
				<string>import OSLog

</string>
				<key>trailing</key>
				<string>extension CapturedRoom.Object: Equatable {
    @available(*, deprecated, message: "This is a very flawed implementation of equatable")
    public static func == (lhs: CapturedRoom.Object, rhs: CapturedRoom.Object) -&gt; Bool {
</string>
			</dict>
			<key>type</key>
			<string>bookmark</string>
		</dict>
		<dict>
			<key>destination</key>
			<dict>
				<key>location-parameters</key>
				<dict>
					<key>EndingColumnNumber</key>
					<string>0</string>
					<key>EndingLineNumber</key>
					<string>30</string>
					<key>StartingColumnNumber</key>
					<string>0</string>
					<key>StartingLineNumber</key>
					<string>29</string>
					<key>Timestamp</key>
					<string>730019319.553911</string>
				</dict>
				<key>rebasable-url</key>
				<dict>
					<key>base</key>
					<string>workspace</string>
					<key>payload</key>
					<dict>
						<key>relative-path</key>
						<string>Organize/Helpers/ColorComponents.swift</string>
					</dict>
				</dict>
			</dict>
			<key>text-context</key>
			<dict>
				<key>focused</key>
				<string>// TODO: Improve how this is implemented, I use the ApproximateEqualTo as a temporary fix. If we strictly compare the RGB values somehow sometimes same color doesn't match. Using an approximate equal with an arbitrary tolerance of 1e-8 seems to fix the issue in the **couple** colors I tested. **NO GUARANTEE** this works for all color, **NO GUARANTEE** this doesn't mix up two colors. Checklist: 1) Investigate new ways to save color to SwiftData without using this ColorComponents workaround or any other workaround 2) Investigate why same color can have two different RGB values. Is it related how SwiftUI resolves Color for light/dark mode? If so, this issue is even more dangerous than it might appear right now. 3) If this deviation is something very innocent (e.g. inaccuracy in bits), figure out what is lowest tolerance threshold.
</string>
				<key>leading</key>
				<string>}

</string>
				<key>trailing</key>
				<string>extension ColorComponents: Equatable {
//    @available(*, deprecated, message: "This is a temporary workaround implementation. Not a strict Equatable implementation. Use with caution.")
    static func == (lhs: Self, rhs: Self) -&gt; Bool {
</string>
			</dict>
			<key>type</key>
			<string>bookmark</string>
		</dict>
	</array>
</dict>
</plist>

<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>top-level-items</key>
	<array>
		<dict>
			<key>destination</key>
			<dict>
				<key>location-parameters</key>
				<dict>
					<key>EndingColumnNumber</key>
					<string>0</string>
					<key>EndingLineNumber</key>
					<string>43</string>
					<key>StartingColumnNumber</key>
					<string>0</string>
					<key>StartingLineNumber</key>
					<string>42</string>
					<key>Timestamp</key>
					<string>729981342.923115</string>
				</dict>
				<key>rebasable-url</key>
				<dict>
					<key>base</key>
					<string>workspace</string>
					<key>payload</key>
					<dict>
						<key>relative-path</key>
						<string>Organize/ContentView.swift</string>
					</dict>
				</dict>
			</dict>
			<key>text-context</key>
			<dict>
				<key>focused</key>
				<string>                    }
</string>
				<key>leading</key>
				<string>                        // Present create item form on dismiss of reconstruction view
                        captureViewModel.showCreateForm = true
</string>
				<key>trailing</key>
				<string>                } content: {
                    if let folderManager = objectCaptureModel.scanFolderManager {
                        ReconstructionPrimaryView(
</string>
			</dict>
			<key>title</key>
			<string>Todo: revisit needed on how to present create item form for capture view</string>
			<key>type</key>
			<string>bookmark</string>
		</dict>
		<dict>
			<key>destination</key>
			<dict>
				<key>location-parameters</key>
				<dict>
					<key>EndingColumnNumber</key>
					<string>0</string>
					<key>EndingLineNumber</key>
					<string>31</string>
					<key>StartingColumnNumber</key>
					<string>0</string>
					<key>StartingLineNumber</key>
					<string>30</string>
					<key>Timestamp</key>
					<string>729804853.105293</string>
				</dict>
				<key>rebasable-url</key>
				<dict>
					<key>base</key>
					<string>workspace</string>
					<key>payload</key>
					<dict>
						<key>relative-path</key>
						<string>Organize/Views/OrganizationTabViews/NavigationColumns/SideBarView.swift</string>
					</dict>
				</dict>
			</dict>
			<key>text-context</key>
			<dict>
				<key>focused</key>
				<string>            // TODO: Improve needed for the match algorithm in this computed property
</string>
				<key>leading</key>
				<string>            return spaces
        } else {
</string>
				<key>trailing</key>
				<string>            // -[ ] Better fuzzy match algorithm
            // -[ ] Implementation in generic of string extension
            return spaces.filter { space in
</string>
			</dict>
			<key>title</key>
			<string>Improve needed for the match algorithm in this computed property</string>
			<key>type</key>
			<string>bookmark</string>
		</dict>
		<dict>
			<key>destination</key>
			<dict>
				<key>location-parameters</key>
				<dict>
					<key>EndingColumnNumber</key>
					<string>0</string>
					<key>EndingLineNumber</key>
					<string>34</string>
					<key>StartingColumnNumber</key>
					<string>0</string>
					<key>StartingLineNumber</key>
					<string>33</string>
					<key>Timestamp</key>
					<string>729874150.833233</string>
				</dict>
				<key>rebasable-url</key>
				<dict>
					<key>base</key>
					<string>workspace</string>
					<key>payload</key>
					<dict>
						<key>relative-path</key>
						<string>Organize/Views/OrganizationTabViews/NavigationColumns/DetailsView.swift</string>
					</dict>
				</dict>
			</dict>
			<key>text-context</key>
			<dict>
				<key>focused</key>
				<string>        // TODO: SwiftUI bug Page Indicator TabView page style lightmode workaround
</string>
				<key>leading</key>
				<string>    
    init() {
</string>
				<key>trailing</key>
				<string>        // PageIndicator of TabViewStyle don't adopt to lightmode for some reason
        // manual implementation for lightmode
        // For currentPageIndicatorTintColor I choose .label, but .tint also works
</string>
			</dict>
			<key>type</key>
			<string>bookmark</string>
		</dict>
		<dict>
			<key>destination</key>
			<dict>
				<key>location-parameters</key>
				<dict>
					<key>EndingColumnNumber</key>
					<string>0</string>
					<key>EndingLineNumber</key>
					<string>28</string>
					<key>StartingColumnNumber</key>
					<string>0</string>
					<key>StartingLineNumber</key>
					<string>27</string>
					<key>Timestamp</key>
					<string>729884771.886156</string>
				</dict>
				<key>rebasable-url</key>
				<dict>
					<key>base</key>
					<string>workspace</string>
					<key>payload</key>
					<dict>
						<key>relative-path</key>
						<string>Organize/Views/OrganizationTabViews/NavigationColumns/ContentColumnView.swift</string>
					</dict>
				</dict>
			</dict>
			<key>text-context</key>
			<dict>
				<key>focused</key>
				<string>        // TODO: Improve needed for the match algorithm in this computed property
</string>
				<key>leading</key>
				<string>    }
    private var storagesList: [Storage] {
</string>
				<key>trailing</key>
				<string>        // -[ ] Better fuzzy match algorithm
        // -[ ] Implementation in generic of string extension
        return storages.filter { storage in
</string>
			</dict>
			<key>type</key>
			<string>bookmark</string>
		</dict>
		<dict>
			<key>destination</key>
			<dict>
				<key>location-parameters</key>
				<dict>
					<key>EndingColumnNumber</key>
					<string>0</string>
					<key>EndingLineNumber</key>
					<string>29</string>
					<key>StartingColumnNumber</key>
					<string>0</string>
					<key>StartingLineNumber</key>
					<string>28</string>
					<key>Timestamp</key>
					<string>729882206.10893</string>
				</dict>
				<key>rebasable-url</key>
				<dict>
					<key>base</key>
					<string>workspace</string>
					<key>payload</key>
					<dict>
						<key>relative-path</key>
						<string>Organize/Views/OrganizationTabViews/NavigationColumns/DetailViews/StorageViews/SingleStorageDetailView.swift</string>
					</dict>
				</dict>
			</dict>
			<key>text-context</key>
			<dict>
				<key>focused</key>
				<string>        // TODO: Improve needed for the match algorithm in this computed property
</string>
				<key>leading</key>
				<string>    }
    private var itemsList: [Item] {
</string>
				<key>trailing</key>
				<string>        // -[ ] Better fuzzy match algorithm
        // -[ ] Implementation in generic of string extension
        return items.filter { item in
</string>
			</dict>
			<key>type</key>
			<string>bookmark</string>
		</dict>
		<dict>
			<key>destination</key>
			<dict>
				<key>location-parameters</key>
				<dict>
					<key>EndingColumnNumber</key>
					<string>47</string>
					<key>EndingLineNumber</key>
					<string>11</string>
					<key>StartingColumnNumber</key>
					<string>47</string>
					<key>StartingLineNumber</key>
					<string>11</string>
					<key>Timestamp</key>
					<string>729975624.3859791</string>
				</dict>
				<key>rebasable-url</key>
				<dict>
					<key>base</key>
					<string>workspace</string>
					<key>payload</key>
					<dict>
						<key>relative-path</key>
						<string>Organize/ViewModels/SpaceScanViewModel.swift</string>
					</dict>
				</dict>
			</dict>
			<key>text-context</key>
			<dict>
				<key>focused</key>
				<string></string>
				<key>leading</key>
				<string>import RoomPlan

// TODO: Upgrade to using observation framework</string>
				<key>trailing</key>
				<string>
class SpaceScanViewModel: ObservableObject {
    enum Action {
</string>
			</dict>
			<key>type</key>
			<string>bookmark</string>
		</dict>
		<dict>
			<key>destination</key>
			<dict>
				<key>location-parameters</key>
				<dict>
					<key>EndingColumnNumber</key>
					<string>108</string>
					<key>EndingLineNumber</key>
					<string>19</string>
					<key>StartingColumnNumber</key>
					<string>108</string>
					<key>StartingLineNumber</key>
					<string>19</string>
					<key>Timestamp</key>
					<string>729975764.996453</string>
				</dict>
				<key>rebasable-url</key>
				<dict>
					<key>base</key>
					<string>workspace</string>
					<key>payload</key>
					<dict>
						<key>relative-path</key>
						<string>Organize/ViewModels/SpaceScanViewModel.swift</string>
					</dict>
				</dict>
			</dict>
			<key>text-context</key>
			<dict>
				<key>focused</key>
				<string></string>
				<key>leading</key>
				<string>    }
    
    // TODO: Is Combine really necessary here? I dislike an observer pattern sticking inside of MVVM pattern</string>
				<key>trailing</key>
				<string>
    // TODO: These are really data models, URLs should be using the same filemanager system CapturedObject is using
    var actions = PassthroughSubject&lt;Action, Never&gt;();
</string>
			</dict>
			<key>type</key>
			<string>bookmark</string>
		</dict>
		<dict>
			<key>destination</key>
			<dict>
				<key>location-parameters</key>
				<dict>
					<key>EndingColumnNumber</key>
					<string>108</string>
					<key>EndingLineNumber</key>
					<string>20</string>
					<key>StartingColumnNumber</key>
					<string>108</string>
					<key>StartingLineNumber</key>
					<string>20</string>
					<key>Timestamp</key>
					<string>729975769.0921</string>
				</dict>
				<key>rebasable-url</key>
				<dict>
					<key>base</key>
					<string>workspace</string>
					<key>payload</key>
					<dict>
						<key>relative-path</key>
						<string>Organize/ViewModels/SpaceScanViewModel.swift</string>
					</dict>
				</dict>
			</dict>
			<key>text-context</key>
			<dict>
				<key>focused</key>
				<string></string>
				<key>leading</key>
				<string>    
    // TODO: Is Combine really necessary here? I dislike an observer pattern sticking inside of MVVM pattern
    // TODO: These are really data models, URLs should be using the same filemanager system CapturedObject i</string>
				<key>trailing</key>
				<string>s using
    var actions = PassthroughSubject&lt;Action, Never&gt;();
    var exportURL = FileManager.default.temporaryDirectory.appending(path: "ScannedSpace.usdz")
</string>
			</dict>
			<key>type</key>
			<string>bookmark</string>
		</dict>
		<dict>
			<key>destination</key>
			<dict>
				<key>location-parameters</key>
				<dict>
					<key>EndingColumnNumber</key>
					<string>0</string>
					<key>EndingLineNumber</key>
					<string>12</string>
					<key>StartingColumnNumber</key>
					<string>0</string>
					<key>StartingLineNumber</key>
					<string>11</string>
					<key>Timestamp</key>
					<string>729977009.093461</string>
				</dict>
				<key>rebasable-url</key>
				<dict>
					<key>base</key>
					<string>workspace</string>
					<key>payload</key>
					<dict>
						<key>relative-path</key>
						<string>Organize/Extensions/CapturedRoom+Equatable.swift</string>
					</dict>
				</dict>
			</dict>
			<key>text-context</key>
			<dict>
				<key>focused</key>
				<string>// TODO: May need a better way, this is extremely sketchy way in so many ways. I implement equitable here to solve a very specific problem of matching two Rooms that have extremely similar coordinates. But extremely similar coordinator of all objects shouldn't mean the CapturedRooms are equal. And other properties is also not consider here.
</string>
				<key>leading</key>
				<string>import OSLog

</string>
				<key>trailing</key>
				<string>extension CapturedRoom: Equatable {
    public static func == (lhs: CapturedRoom, rhs: CapturedRoom) -&gt; Bool {
        logger.warning("Equatable implementation for CaptureRoom is very flawed at this moment because it only compare objects of two CapturedRooms without taking account of other properties. And Object's implementation is also flawed")
</string>
			</dict>
			<key>type</key>
			<string>bookmark</string>
		</dict>
		<dict>
			<key>destination</key>
			<dict>
				<key>location-parameters</key>
				<dict>
					<key>EndingColumnNumber</key>
					<string>0</string>
					<key>EndingLineNumber</key>
					<string>12</string>
					<key>StartingColumnNumber</key>
					<string>0</string>
					<key>StartingLineNumber</key>
					<string>11</string>
					<key>Timestamp</key>
					<string>729976769.160261</string>
				</dict>
				<key>rebasable-url</key>
				<dict>
					<key>base</key>
					<string>workspace</string>
					<key>payload</key>
					<dict>
						<key>relative-path</key>
						<string>Organize/Extensions/CapturedRoom.Object+Equatable.swift</string>
					</dict>
				</dict>
			</dict>
			<key>text-context</key>
			<dict>
				<key>focused</key>
				<string>// TODO: May need a better way, this is extremely sketchy way in so many ways. I implement equitable here to solve a very specific problem of matching two Rooms that have extremely similar coordinates. But extremely similar coordinator of all objects shouldn't mean the CapturedRooms are equal. And other properties is also not consider here.
</string>
				<key>leading</key>
				<string>import OSLog

</string>
				<key>trailing</key>
				<string>extension CapturedRoom.Object: Equatable {
    @available(*, deprecated, message: "This is a very flawed implementation of equatable")
    public static func == (lhs: CapturedRoom.Object, rhs: CapturedRoom.Object) -&gt; Bool {
</string>
			</dict>
			<key>type</key>
			<string>bookmark</string>
		</dict>
	</array>
</dict>
</plist>
